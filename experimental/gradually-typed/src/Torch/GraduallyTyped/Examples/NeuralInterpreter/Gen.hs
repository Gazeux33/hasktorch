{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Torch.GraduallyTyped.Examples.NeuralInterpreter.Gen where

import Bound (instantiate1)
import Control.Applicative (Alternative (empty), (<|>))
import Control.Monad.Fresh (FreshT, MonadFresh (fresh), runFreshT)
import Control.Monad.Reader (MonadReader (ask, local), ReaderT (runReaderT), MonadTrans (lift))
import Control.Monad.State (MonadState (get, put), StateT)
import qualified Data.List as List
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Maybe (fromMaybe)
import Hedgehog (Gen, MonadGen, GenT)
import qualified Hedgehog.Gen as Gen
import qualified Hedgehog.Internal.Gen as Gen
import qualified Hedgehog.Internal.Seed as Seed
import qualified Hedgehog.Internal.Tree as Tree
import qualified Hedgehog.Range as Range
import Torch.GraduallyTyped.Examples.NeuralInterpreter.STLC (Exp (..), Ty (..), lam, nat, whnf)

-- | Monad transformer stack for term and type generation.
-- Notably, contains the @FreshT@ transformer for generating fresh variable names
-- and a @ReaderT@ for the environment of scoped typed @Var@s.
type GTyM a = ReaderT (Map Ty [Exp a]) (FreshT a Gen)

-- | Generate a type.
-- We cannot generate an expression without generating a type for it first.
genTy :: forall m. MonadGen m => m Ty
genTy =
  Gen.recursive
    Gen.choice
    [ -- non-recursive generators
      pure Nat
    ]
    [ -- recursive generators
      Arr <$> genTy <*> genTy
    ]

-- | Finalize generation by running the monad transformers for the environment
-- and the fresh variable name computation.
genWellTypedExp :: forall a. (Eq a, Enum a) => Ty -> Gen (Exp a)
genWellTypedExp ty' = runFreshT $ runReaderT (genWellTypedExp' ty') mempty

-- | Main recursive mechanism for genersating expressions for a given type.
genWellTypedExp' :: forall a. Eq a => Ty -> GTyM a (Exp a)
genWellTypedExp' ty' =
  Gen.shrink shrinkExp $
    genWellTypedPath ty'
      <|> Gen.recursive
        Gen.choice
        [ -- non-recursive generators
          genWellTypedExp'' ty'
        ]
        [ -- recursive generators
          genWellTypedApp ty',
          genWellTypedExp''' ty'
        ]

shrinkExp :: forall a. Exp a -> [Exp a]
shrinkExp (f :@ a) = case whnf f of
  Lam _ b -> [whnf (instantiate1 a b)]
  _ -> []
shrinkExp _ = []

-- | Pattern match on a given type and produce a corresponding term.
-- @Lam@ is generated from @Arr@ by first obtaining a fresh variable name for @Var@ and
-- then calling the @lam@ smart constructor on an expression that
-- was produced for an environment to which @Var@ was added.
-- A term of type @Nat@ is generated by converting a random integer through induction.
genWellTypedExp'' :: forall a. Eq a => Ty -> GTyM a (Exp a)
genWellTypedExp'' (Arr ty' ty'') = do
  uname <- fresh
  lam ty' uname <$> local (insertVar uname ty') (genWellTypedExp' ty'')
genWellTypedExp'' Nat = nat <$> Gen.int (Range.linear 0 10)

genWellTypedExp''' :: forall a. Eq a => Ty -> GTyM a (Exp a)
genWellTypedExp''' Nat = Succ <$> genWellTypedExp' Nat
genWellTypedExp''' ty' = genWellTypedExp' ty'

-- | Add @Var@ of given type to the given env so that it can be used for sampling later.
insertVar :: forall a. Eq a => a -> Ty -> Map Ty [Exp a] -> Map Ty [Exp a]
insertVar uname ty' =
  Map.insertWith (<>) ty' [Var uname] . fmap (List.filter (/= Var uname))

-- | Generate app by first producing type and value of the argument
-- and then generating a compatible @Lam@.
genWellTypedApp :: forall a. Eq a => Ty -> GTyM a (Exp a)
genWellTypedApp ty' = do
  tg <- genKnownTypeMaybe
  eg <- genWellTypedExp' tg
  let tf = Arr tg ty'
  ef <- genWellTypedExp' tf
  pure (ef :@ eg)

-- | Try to look up a known expression of the desired type from the environment.
-- This does not always succceed, throwing `empty` when unavailable.
genWellTypedPath :: forall a. Ty -> GTyM a (Exp a)
genWellTypedPath ty' = do
  paths <- ask
  case fromMaybe [] (Map.lookup ty' paths) of
    [] -> empty
    es -> Gen.element es

-- | Generate either known types from the environment or new types.
genKnownTypeMaybe :: forall a. GTyM a Ty
genKnownTypeMaybe = do
  known <- ask
  if Map.null known
    then genTy
    else
      Gen.frequency
        [ (2, Gen.element $ Map.keys known),
          (1, genTy)
        ]

sample' :: forall m a. Monad m => GenT m a -> StateT Seed.Seed m a
sample' gen =
  let go :: StateT Seed.Seed m a
      go = do
        seed <- get
        let (seed', seed'') = Seed.split seed
        put seed''
        Tree.NodeT x _ <- lift . Tree.runTreeT . Gen.evalGenT 30 seed' $ gen
        maybe go pure x
   in go