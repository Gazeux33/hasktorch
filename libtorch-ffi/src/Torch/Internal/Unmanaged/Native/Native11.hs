
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Torch.Internal.Unmanaged.Native.Native11 where


import Foreign.C.String
import Foreign.C.Types
import Foreign
import Torch.Internal.Type

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<vector>"
C.include "<ATen/Tensor.h>"
C.include "<ATen/Functions.h>"


ormqr_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ormqr_out_tttt _out _self _input2 _input3 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ormqr_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)));
  }|]

ormqr_tttbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
ormqr_tttbb _self _input2 _input3 _left _transpose =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ormqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)
  , $(bool _left)
  , $(bool _transpose)));
  }|]

ormqr_tttb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> CBool
  -> IO (Ptr Tensor)
ormqr_tttb _self _input2 _input3 _left =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ormqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)
  , $(bool _left)));
  }|]

ormqr_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
ormqr_ttt _self _input2 _input3 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::ormqr(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _input2)
  , *$(at::Tensor* _input3)));
  }|]

_lu_with_info_tbb
  :: Ptr Tensor
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_lu_with_info_tbb _self _pivot _check_errors =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_lu_with_info(
    *$(at::Tensor* _self)
  , $(bool _pivot)
  , $(bool _check_errors)));
  }|]

_lu_with_info_tb
  :: Ptr Tensor
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_lu_with_info_tb _self _pivot =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_lu_with_info(
    *$(at::Tensor* _self)
  , $(bool _pivot)));
  }|]

_lu_with_info_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor,Tensor)))
_lu_with_info_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor,at::Tensor>(at::_lu_with_info(
    *$(at::Tensor* _self)));
  }|]

lu_solve_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lu_solve_out_tttt _out _self _LU_data _LU_pivots =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lu_solve_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _LU_data)
  , *$(at::Tensor* _LU_pivots)));
  }|]

lu_solve_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lu_solve_ttt _self _LU_data _LU_pivots =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lu_solve(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _LU_data)
  , *$(at::Tensor* _LU_pivots)));
  }|]

_lu_solve_helper_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_lu_solve_helper_ttt _self _LU_data _LU_pivots =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_lu_solve_helper(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _LU_data)
  , *$(at::Tensor* _LU_pivots)));
  }|]

multinomial_out_ttlbG
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
multinomial_out_ttlbG _out _self _num_samples _replacement _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _num_samples)
  , $(bool _replacement)
  , *$(at::Generator* _generator)));
  }|]

multinomial_out_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
multinomial_out_ttlb _out _self _num_samples _replacement =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _num_samples)
  , $(bool _replacement)));
  }|]

multinomial_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multinomial_out_ttl _out _self _num_samples =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _num_samples)));
  }|]

multinomial_tlbG
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
multinomial_tlbG _self _num_samples _replacement _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial(
    *$(at::Tensor* _self)
  , $(int64_t _num_samples)
  , $(bool _replacement)
  , *$(at::Generator* _generator)));
  }|]

multinomial_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
multinomial_tlb _self _num_samples _replacement =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial(
    *$(at::Tensor* _self)
  , $(int64_t _num_samples)
  , $(bool _replacement)));
  }|]

multinomial_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multinomial_tl _self _num_samples =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multinomial(
    *$(at::Tensor* _self)
  , $(int64_t _num_samples)));
  }|]

_multinomial_alias_setup_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
_multinomial_alias_setup_t _probs =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::_multinomial_alias_setup(
    *$(at::Tensor* _probs)));
  }|]

_multinomial_alias_draw_ttlG
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Generator
  -> IO (Ptr Tensor)
_multinomial_alias_draw_ttlG _J _q _num_samples _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_multinomial_alias_draw(
    *$(at::Tensor* _J)
  , *$(at::Tensor* _q)
  , $(int64_t _num_samples)
  , *$(at::Generator* _generator)));
  }|]

_multinomial_alias_draw_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
_multinomial_alias_draw_ttl _J _q _num_samples =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_multinomial_alias_draw(
    *$(at::Tensor* _J)
  , *$(at::Tensor* _q)
  , $(int64_t _num_samples)));
  }|]

lgamma_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lgamma_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lgamma_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

lgamma_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
lgamma_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lgamma(
    *$(at::Tensor* _self)));
  }|]

digamma_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
digamma_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::digamma_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

digamma_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
digamma_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::digamma(
    *$(at::Tensor* _self)));
  }|]

polygamma_out_tlt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
polygamma_out_tlt _out _n _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::polygamma_out(
    *$(at::Tensor* _out)
  , $(int64_t _n)
  , *$(at::Tensor* _self)));
  }|]

polygamma_lt
  :: Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
polygamma_lt _n _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::polygamma(
    $(int64_t _n)
  , *$(at::Tensor* _self)));
  }|]

erfinv_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
erfinv_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::erfinv(
    *$(at::Tensor* _self)));
  }|]

erfinv_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
erfinv_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::erfinv_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

i0_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
i0_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::i0(
    *$(at::Tensor* _self)));
  }|]

i0__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
i0__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::i0_(
    *$(at::Tensor* _self)));
  }|]

i0_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
i0_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::i0_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

sign_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
sign_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sign(
    *$(at::Tensor* _self)));
  }|]

sign_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
sign_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::sign_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

signbit_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
signbit_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::signbit(
    *$(at::Tensor* _self)));
  }|]

signbit_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
signbit_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::signbit_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

dist_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
dist_tts _self _other _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dist(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)
  , *$(at::Scalar* _p)));
  }|]

dist_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
dist_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::dist(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

atan2_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan2_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atan2_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

atan2_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
atan2_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::atan2(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

lerp_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lerp_out_ttts _out _self _end _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lerp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Scalar* _weight)));
  }|]

lerp_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lerp_out_tttt _out _self _end _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lerp_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Tensor* _weight)));
  }|]

lerp_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
lerp_tts _self _end _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lerp(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Scalar* _weight)));
  }|]

lerp_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
lerp_ttt _self _end _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::lerp(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _end)
  , *$(at::Tensor* _weight)));
  }|]

histc_out_ttlss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
histc_out_ttlss _out _self _bins _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _bins)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

histc_out_ttls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Scalar
  -> IO (Ptr Tensor)
histc_out_ttls _out _self _bins _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _bins)
  , *$(at::Scalar* _min)));
  }|]

histc_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
histc_out_ttl _out _self _bins =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _bins)));
  }|]

histc_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
histc_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

histc_tlss
  :: Ptr Tensor
  -> Int64
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
histc_tlss _self _bins _min _max =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc(
    *$(at::Tensor* _self)
  , $(int64_t _bins)
  , *$(at::Scalar* _min)
  , *$(at::Scalar* _max)));
  }|]

histc_tls
  :: Ptr Tensor
  -> Int64
  -> Ptr Scalar
  -> IO (Ptr Tensor)
histc_tls _self _bins _min =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc(
    *$(at::Tensor* _self)
  , $(int64_t _bins)
  , *$(at::Scalar* _min)));
  }|]

histc_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
histc_tl _self _bins =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc(
    *$(at::Tensor* _self)
  , $(int64_t _bins)));
  }|]

histc_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
histc_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::histc(
    *$(at::Tensor* _self)));
  }|]

fmod_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fmod_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fmod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

fmod_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
fmod_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fmod(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

fmod_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fmod_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fmod_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

fmod_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
fmod_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::fmod(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

hypot_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hypot_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hypot_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

hypot_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hypot_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hypot(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

nextafter_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nextafter_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nextafter_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

nextafter_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nextafter_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nextafter(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

remainder_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
remainder_out_tts _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::remainder_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

remainder_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
remainder_ts _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::remainder(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _other)));
  }|]

remainder_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
remainder_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::remainder_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

remainder_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
remainder_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::remainder(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
min_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::min(
    *$(at::Tensor* _self)));
  }|]

max_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
max_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max(
    *$(at::Tensor* _self)));
  }|]

maximum_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
maximum_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::maximum(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

maximum_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
maximum_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::maximum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

max_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

max_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
max_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::max_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

minimum_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
minimum_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::minimum(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

minimum_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
minimum_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::minimum_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
min_out_ttt _out _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::min_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

min_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
min_tt _self _other =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::min(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

median_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
median_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::median(
    *$(at::Tensor* _self)));
  }|]

quantile_out_ttdlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
quantile_out_ttdlb _out _self _q _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(double _q)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

quantile_out_ttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
quantile_out_ttdl _out _self _q _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(double _q)
  , $(int64_t _dim)));
  }|]

quantile_out_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
quantile_out_ttd _out _self _q =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(double _q)));
  }|]

quantile_tdlb
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
quantile_tdlb _self _q _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile(
    *$(at::Tensor* _self)
  , $(double _q)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

quantile_tdl
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
quantile_tdl _self _q _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile(
    *$(at::Tensor* _self)
  , $(double _q)
  , $(int64_t _dim)));
  }|]

quantile_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
quantile_td _self _q =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile(
    *$(at::Tensor* _self)
  , $(double _q)));
  }|]

quantile_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
quantile_out_tttlb _out _self _q _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _q)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

quantile_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
quantile_out_tttl _out _self _q _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _q)
  , $(int64_t _dim)));
  }|]

quantile_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
quantile_out_ttt _out _self _q =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _q)));
  }|]

quantile_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
quantile_ttlb _self _q _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _q)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

quantile_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
quantile_ttl _self _q _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _q)
  , $(int64_t _dim)));
  }|]

quantile_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
quantile_tt _self _q =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::quantile(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _q)));
  }|]

nanquantile_out_ttdlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
nanquantile_out_ttdlb _out _self _q _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(double _q)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

nanquantile_out_ttdl
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
nanquantile_out_ttdl _out _self _q _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(double _q)
  , $(int64_t _dim)));
  }|]

nanquantile_out_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
nanquantile_out_ttd _out _self _q =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(double _q)));
  }|]

nanquantile_tdlb
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
nanquantile_tdlb _self _q _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile(
    *$(at::Tensor* _self)
  , $(double _q)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

nanquantile_tdl
  :: Ptr Tensor
  -> CDouble
  -> Int64
  -> IO (Ptr Tensor)
nanquantile_tdl _self _q _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile(
    *$(at::Tensor* _self)
  , $(double _q)
  , $(int64_t _dim)));
  }|]

nanquantile_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
nanquantile_td _self _q =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile(
    *$(at::Tensor* _self)
  , $(double _q)));
  }|]

nanquantile_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
nanquantile_out_tttlb _out _self _q _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _q)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

nanquantile_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
nanquantile_out_tttl _out _self _q _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _q)
  , $(int64_t _dim)));
  }|]

nanquantile_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nanquantile_out_ttt _out _self _q =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _q)));
  }|]

nanquantile_ttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
nanquantile_ttlb _self _q _dim _keepdim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _q)
  , $(int64_t _dim)
  , $(bool _keepdim)));
  }|]

nanquantile_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
nanquantile_ttl _self _q _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _q)
  , $(int64_t _dim)));
  }|]

nanquantile_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nanquantile_tt _self _q =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nanquantile(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _q)));
  }|]

sort_out_tttlb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_out_tttlb _values _indices _self _dim _descending =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _descending)));
  }|]

sort_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_out_tttl _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

sort_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_out_ttt _values _indices _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)));
  }|]

sort_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_tlb _self _dim _descending =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _descending)));
  }|]

sort_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_tl _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

sort_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)));
  }|]

sort_out_tttnb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_out_tttnb _values _indices _self _dim _descending =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _descending)));
  }|]

sort_out_tttn
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_out_tttn _values _indices _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

sort_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_tnb _self _dim _descending =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _descending)));
  }|]

sort_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
sort_tn _self _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::sort(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

argsort_tlb
  :: Ptr Tensor
  -> Int64
  -> CBool
  -> IO (Ptr Tensor)
argsort_tlb _self _dim _descending =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , $(bool _descending)));
  }|]

argsort_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
argsort_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

argsort_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
argsort_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)));
  }|]

argsort_tnb
  :: Ptr Tensor
  -> Ptr Dimname
  -> CBool
  -> IO (Ptr Tensor)
argsort_tnb _self _dim _descending =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)
  , $(bool _descending)));
  }|]

argsort_tn
  :: Ptr Tensor
  -> Ptr Dimname
  -> IO (Ptr Tensor)
argsort_tn _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::argsort(
    *$(at::Tensor* _self)
  , *$(at::Dimname* _dim)));
  }|]

topk_out_tttllbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_out_tttllbb _values _indices _self _k _dim _largest _sorted =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _largest)
  , $(bool _sorted)));
  }|]

topk_out_tttllb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_out_tttllb _values _indices _self _k _dim _largest =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _largest)));
  }|]

topk_out_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_out_tttll _values _indices _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)));
  }|]

topk_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_out_tttl _values _indices _self _k =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk_out(
    *$(at::Tensor* _values)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , $(int64_t _k)));
  }|]

topk_tllbb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_tllbb _self _k _dim _largest _sorted =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _largest)
  , $(bool _sorted)));
  }|]

topk_tllb
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> CBool
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_tllb _self _k _dim _largest =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)
  , $(bool _largest)));
  }|]

topk_tll
  :: Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_tll _self _k _dim =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk(
    *$(at::Tensor* _self)
  , $(int64_t _k)
  , $(int64_t _dim)));
  }|]

topk_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
topk_tl _self _k =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::topk(
    *$(at::Tensor* _self)
  , $(int64_t _k)));
  }|]

all_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
all_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::all(
    *$(at::Tensor* _self)));
  }|]

any_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
any_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::any(
    *$(at::Tensor* _self)));
  }|]

renorm_out_ttsls
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Int64
  -> Ptr Scalar
  -> IO (Ptr Tensor)
renorm_out_ttsls _out _self _p _dim _maxnorm =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::renorm_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(int64_t _dim)
  , *$(at::Scalar* _maxnorm)));
  }|]

renorm_tsls
  :: Ptr Tensor
  -> Ptr Scalar
  -> Int64
  -> Ptr Scalar
  -> IO (Ptr Tensor)
renorm_tsls _self _p _dim _maxnorm =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::renorm(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _p)
  , $(int64_t _dim)
  , *$(at::Scalar* _maxnorm)));
  }|]

unfold_backward_tllll
  :: Ptr Tensor
  -> Ptr IntArray
  -> Int64
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
unfold_backward_tllll _grad_in _input_sizes _dim _size _step =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::unfold_backward(
    *$(at::Tensor* _grad_in)
  , *$(std::vector<int64_t>* _input_sizes)
  , $(int64_t _dim)
  , $(int64_t _size)
  , $(int64_t _step)));
  }|]

equal_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (CBool)
equal_tt _self _other =
  [C.throwBlock| bool { return (at::equal(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _other)));
  }|]

pow_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_out_ttt _out _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_tt _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_out_tst
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_out_tst _out _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Scalar* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_st
  :: Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
pow_st _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow(
    *$(at::Scalar* _self)
  , *$(at::Tensor* _exponent)));
  }|]

pow_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow_out_tts _out _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

pow_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
pow_ts _self _exponent =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::pow(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _exponent)));
  }|]

normal_out_ttdG
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_ttdG _out _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)
  , $(double _std)
  , *$(at::Generator* _generator)));
  }|]

normal_out_ttd
  :: Ptr Tensor
  -> Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
normal_out_ttd _out _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)
  , $(double _std)));
  }|]

normal_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
normal_out_tt _out _mean =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)));
  }|]

normal_tdG
  :: Ptr Tensor
  -> CDouble
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_tdG _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)
  , $(double _std)
  , *$(at::Generator* _generator)));
  }|]

normal_td
  :: Ptr Tensor
  -> CDouble
  -> IO (Ptr Tensor)
normal_td _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)
  , $(double _std)));
  }|]

normal_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
normal_t _mean =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)));
  }|]

normal_out_tdtG
  :: Ptr Tensor
  -> CDouble
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_tdtG _out _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , $(double _mean)
  , *$(at::Tensor* _std)
  , *$(at::Generator* _generator)));
  }|]

normal_out_tdt
  :: Ptr Tensor
  -> CDouble
  -> Ptr Tensor
  -> IO (Ptr Tensor)
normal_out_tdt _out _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , $(double _mean)
  , *$(at::Tensor* _std)));
  }|]

normal_dtG
  :: CDouble
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_dtG _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , *$(at::Tensor* _std)
  , *$(at::Generator* _generator)));
  }|]

normal_dt
  :: CDouble
  -> Ptr Tensor
  -> IO (Ptr Tensor)
normal_dt _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , *$(at::Tensor* _std)));
  }|]

normal_out_tttG
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_tttG _out _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)
  , *$(at::Generator* _generator)));
  }|]

normal_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
normal_out_ttt _out _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)));
  }|]

normal_ttG
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_ttG _mean _std _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)
  , *$(at::Generator* _generator)));
  }|]

normal_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
normal_tt _mean _std =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    *$(at::Tensor* _mean)
  , *$(at::Tensor* _std)));
  }|]

normal_ddlGo
  :: CDouble
  -> CDouble
  -> Ptr IntArray
  -> Ptr Generator
  -> Ptr TensorOptions
  -> IO (Ptr Tensor)
normal_ddlGo _mean _std _size _generator _options =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , $(double _std)
  , *$(std::vector<int64_t>* _size)
  , *$(at::Generator* _generator)
  , *$(at::TensorOptions* _options)));
  }|]

normal_ddlG
  :: CDouble
  -> CDouble
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_ddlG _mean _std _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , $(double _std)
  , *$(std::vector<int64_t>* _size)
  , *$(at::Generator* _generator)));
  }|]

normal_ddl
  :: CDouble
  -> CDouble
  -> Ptr IntArray
  -> IO (Ptr Tensor)
normal_ddl _mean _std _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal(
    $(double _mean)
  , $(double _std)
  , *$(std::vector<int64_t>* _size)));
  }|]

normal_out_tddlG
  :: Ptr Tensor
  -> CDouble
  -> CDouble
  -> Ptr IntArray
  -> Ptr Generator
  -> IO (Ptr Tensor)
normal_out_tddlG _out _mean _std _size _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , $(double _mean)
  , $(double _std)
  , *$(std::vector<int64_t>* _size)
  , *$(at::Generator* _generator)));
  }|]

normal_out_tddl
  :: Ptr Tensor
  -> CDouble
  -> CDouble
  -> Ptr IntArray
  -> IO (Ptr Tensor)
normal_out_tddl _out _mean _std _size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::normal_out(
    *$(at::Tensor* _out)
  , $(double _mean)
  , $(double _std)
  , *$(std::vector<int64_t>* _size)));
  }|]

alias_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
alias_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::alias(
    *$(at::Tensor* _self)));
  }|]

_index_copy__tltt
  :: Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_index_copy__tltt _self _dim _index _source =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_index_copy_(
    *$(at::Tensor* _self)
  , $(int64_t _dim)
  , *$(at::Tensor* _index)
  , *$(at::Tensor* _source)));
  }|]

