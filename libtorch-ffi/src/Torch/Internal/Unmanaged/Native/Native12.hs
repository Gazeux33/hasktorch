
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Torch.Internal.Unmanaged.Native.Native12 where


import Foreign.C.String
import Foreign.C.Types
import Foreign
import Torch.Internal.Type

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<vector>"
C.include "<ATen/Tensor.h>"
C.include "<ATen/Functions.h>"


searchsorted_tsbb
  :: Ptr Tensor
  -> Ptr Scalar
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
searchsorted_tsbb _sorted_sequence _self _out_int32 _right =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::searchsorted(
    *$(at::Tensor* _sorted_sequence)
  , *$(at::Scalar* _self)
  , $(bool _out_int32)
  , $(bool _right)));
  }|]

searchsorted_tsb
  :: Ptr Tensor
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
searchsorted_tsb _sorted_sequence _self _out_int32 =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::searchsorted(
    *$(at::Tensor* _sorted_sequence)
  , *$(at::Scalar* _self)
  , $(bool _out_int32)));
  }|]

searchsorted_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
searchsorted_ts _sorted_sequence _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::searchsorted(
    *$(at::Tensor* _sorted_sequence)
  , *$(at::Scalar* _self)));
  }|]

mse_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_out_tttl _out _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

mse_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mse_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

mse_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

mse_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
mse_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

mse_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

mse_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
mse_loss_backward_tttl _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mse_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_out_tttl _out _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
l1_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

l1_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
l1_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

l1_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

l1_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
l1_loss_backward_tttl _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::l1_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_out_tttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_out_tttsstl _out _self _target _p _margin _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_out_tttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_out_tttsst _out _self _target _p _margin _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)));
  }|]

multi_margin_loss_out_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_out_tttss _out _self _target _p _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)));
  }|]

multi_margin_loss_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_out_ttts _out _self _target _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)));
  }|]

multi_margin_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

multi_margin_loss_ttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_ttsstl _self _target _p _margin _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_ttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_ttsst _self _target _p _margin _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)));
  }|]

multi_margin_loss_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_ttss _self _target _p _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)));
  }|]

multi_margin_loss_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_tts _self _target _p =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)));
  }|]

multi_margin_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

multi_margin_loss_backward_out_ttttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_backward_out_ttttsstl _grad_input _grad_output _self _target _p _margin _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_backward_out_ttttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_backward_out_ttttsst _grad_input _grad_output _self _target _p _margin _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)));
  }|]

multi_margin_loss_backward_out_ttttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_backward_out_ttttss _grad_input _grad_output _self _target _p _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)));
  }|]

multi_margin_loss_backward_tttsstl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multi_margin_loss_backward_tttsstl _grad_output _self _target _p _margin _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

multi_margin_loss_backward_tttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multi_margin_loss_backward_tttsst _grad_output _self _target _p _margin _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)
  , *$(at::Tensor* _weight)));
  }|]

multi_margin_loss_backward_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
multi_margin_loss_backward_tttss _grad_output _self _target _p _margin =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multi_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Scalar* _p)
  , *$(at::Scalar* _margin)));
  }|]

multilabel_margin_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multilabel_margin_loss_out_tttl _out _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

multilabel_margin_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
multilabel_margin_loss_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

multilabel_margin_loss_forward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
multilabel_margin_loss_forward_out_ttttl _output _is_target _self _target _reduction =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::multilabel_margin_loss_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _is_target)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_forward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
multilabel_margin_loss_forward_ttl _self _target _reduction =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::multilabel_margin_loss_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

multilabel_margin_loss_backward_out_ttttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_backward_out_ttttlt _grad_input _grad_output _self _target _reduction _is_target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)
  , *$(at::Tensor* _is_target)));
  }|]

multilabel_margin_loss_backward_tttlt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
multilabel_margin_loss_backward_tttlt _grad_output _self _target _reduction _is_target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::multilabel_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)
  , *$(at::Tensor* _is_target)));
  }|]

nll_loss_out_ttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss_out_ttttll _out _self _target _weight _reduction _ignore_index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
nll_loss_out_ttttl _out _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

nll_loss_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_out_tttt _out _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

nll_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

nll_loss_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss_tttll _self _target _weight _reduction _ignore_index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
nll_loss_tttl _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

nll_loss_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_ttt _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

nll_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

nll_loss_forward_out_tttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
nll_loss_forward_out_tttttll _output _total_weight _self _target _weight _reduction _ignore_index =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _total_weight)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_forward_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
nll_loss_forward_tttll _self _target _weight _reduction _ignore_index =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss_backward_out_tttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_backward_out_tttttllt _grad_input _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss_backward_ttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss_backward_ttttllt _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss2d_out_ttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss2d_out_ttttll _out _self _target _weight _reduction _ignore_index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
nll_loss2d_out_ttttl _out _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

nll_loss2d_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_out_tttt _out _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

nll_loss2d_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

nll_loss2d_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr Tensor)
nll_loss2d_tttll _self _target _weight _reduction _ignore_index =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
nll_loss2d_tttl _self _target _weight _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)));
  }|]

nll_loss2d_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_ttt _self _target _weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)));
  }|]

nll_loss2d_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

nll_loss2d_forward_out_tttttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
nll_loss2d_forward_out_tttttll _output _total_weight _self _target _weight _reduction _ignore_index =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss2d_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _total_weight)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_forward_tttll
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
nll_loss2d_forward_tttll _self _target _weight _reduction _ignore_index =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::nll_loss2d_forward(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)));
  }|]

nll_loss2d_backward_out_tttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_backward_out_tttttllt _grad_input _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

nll_loss2d_backward_ttttllt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> Int64
  -> Ptr Tensor
  -> IO (Ptr Tensor)
nll_loss2d_backward_ttttllt _grad_output _self _target _weight _reduction _ignore_index _total_weight =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::nll_loss2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , *$(at::Tensor* _weight)
  , $(int64_t _reduction)
  , $(int64_t _ignore_index)
  , *$(at::Tensor* _total_weight)));
  }|]

smooth_l1_loss_out_tttld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
smooth_l1_loss_out_tttld _out _self _target _reduction _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)
  , $(double _beta)));
  }|]

smooth_l1_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
smooth_l1_loss_out_tttl _out _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

smooth_l1_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
smooth_l1_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

smooth_l1_loss_ttld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
smooth_l1_loss_ttld _self _target _reduction _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)
  , $(double _beta)));
  }|]

smooth_l1_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
smooth_l1_loss_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

smooth_l1_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
smooth_l1_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

smooth_l1_loss_backward_out_ttttld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
smooth_l1_loss_backward_out_ttttld _grad_input _grad_output _self _target _reduction _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)
  , $(double _beta)));
  }|]

smooth_l1_loss_backward_tttld
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> CDouble
  -> IO (Ptr Tensor)
smooth_l1_loss_backward_tttld _grad_output _self _target _reduction _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::smooth_l1_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)
  , $(double _beta)));
  }|]

soft_margin_loss_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_out_tttl _out _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
soft_margin_loss_out_ttt _out _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

soft_margin_loss_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_ttl _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
soft_margin_loss_tt _self _target =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _target)));
  }|]

soft_margin_loss_backward_out_ttttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_backward_out_ttttl _grad_input _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

soft_margin_loss_backward_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
soft_margin_loss_backward_tttl _grad_output _self _target _reduction =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::soft_margin_loss_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _target)
  , $(int64_t _reduction)));
  }|]

elu_out_ttsss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_out_ttsss _out _self _alpha _scale _input_scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

elu_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_out_ttss _out _self _alpha _scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)));
  }|]

elu_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_out_tts _out _self _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

elu_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
elu_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

elu_tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_tsss _self _alpha _scale _input_scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

elu_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_tss _self _alpha _scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)));
  }|]

elu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu_ts _self _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

elu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
elu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu(
    *$(at::Tensor* _self)));
  }|]

elu_backward_tsssbt
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Tensor
  -> IO (Ptr Tensor)
elu_backward_tsssbt _grad_output _alpha _scale _input_scale _is_result _self_or_result =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)
  , $(bool _is_result)
  , *$(at::Tensor* _self_or_result)));
  }|]

elu__tsss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu__tsss _self _alpha _scale _input_scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)
  , *$(at::Scalar* _input_scale)));
  }|]

elu__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu__tss _self _alpha _scale =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)
  , *$(at::Scalar* _scale)));
  }|]

elu__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
elu__ts _self _alpha =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _alpha)));
  }|]

elu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
elu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::elu_(
    *$(at::Tensor* _self)));
  }|]

glu_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_out_ttl _out _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

glu_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
glu_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

glu_tl
  :: Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_tl _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu(
    *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

glu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
glu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu(
    *$(at::Tensor* _self)));
  }|]

glu_backward_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_backward_out_tttl _grad_input _grad_output _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

glu_backward_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Int64
  -> IO (Ptr Tensor)
glu_backward_ttl _grad_output _self _dim =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::glu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , $(int64_t _dim)));
  }|]

hardsigmoid_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hardsigmoid_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardsigmoid_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

hardsigmoid_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardsigmoid_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardsigmoid(
    *$(at::Tensor* _self)));
  }|]

hardsigmoid__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardsigmoid__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardsigmoid_(
    *$(at::Tensor* _self)));
  }|]

hardsigmoid_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hardsigmoid_backward_tt _grad_output _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardsigmoid_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

hardtanh_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_out_ttss _out _self _min_val _max_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_out_tts _out _self _min_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)));
  }|]

hardtanh_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hardtanh_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

hardtanh_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_tss _self _min_val _max_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_ts _self _min_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)));
  }|]

hardtanh_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardtanh_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh(
    *$(at::Tensor* _self)));
  }|]

hardtanh_backward_out_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_backward_out_tttss _grad_input _grad_output _self _min_val _max_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh_backward_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh_backward_ttss _grad_output _self _min_val _max_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh__tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh__tss _self _min_val _max_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)
  , *$(at::Scalar* _max_val)));
  }|]

hardtanh__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
hardtanh__ts _self _min_val =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _min_val)));
  }|]

hardtanh__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardtanh__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardtanh_(
    *$(at::Tensor* _self)));
  }|]

hardswish_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hardswish_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardswish_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

hardswish_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardswish_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardswish(
    *$(at::Tensor* _self)));
  }|]

hardswish__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
hardswish__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardswish_(
    *$(at::Tensor* _self)));
  }|]

hardswish_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
hardswish_backward_tt _grad_output _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::hardswish_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

leaky_relu_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_out_tts _out _self _negative_slope =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
leaky_relu_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

leaky_relu_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu_ts _self _negative_slope =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
leaky_relu_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu(
    *$(at::Tensor* _self)));
  }|]

leaky_relu_backward_ttsb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
leaky_relu_backward_ttsb _grad_output _self _negative_slope _self_is_result =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)
  , $(bool _self_is_result)));
  }|]

leaky_relu__ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
leaky_relu__ts _self _negative_slope =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu_(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _negative_slope)));
  }|]

leaky_relu__t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
leaky_relu__t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::leaky_relu_(
    *$(at::Tensor* _self)));
  }|]

log_sigmoid_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_sigmoid_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

log_sigmoid_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_sigmoid(
    *$(at::Tensor* _self)));
  }|]

log_sigmoid_forward_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
log_sigmoid_forward_out_ttt _output _buffer _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::log_sigmoid_forward_out(
    *$(at::Tensor* _output)
  , *$(at::Tensor* _buffer)
  , *$(at::Tensor* _self)));
  }|]

log_sigmoid_forward_t
  :: Ptr Tensor
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
log_sigmoid_forward_t _self =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::log_sigmoid_forward(
    *$(at::Tensor* _self)));
  }|]

log_sigmoid_backward_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_backward_out_tttt _grad_input _grad_output _self _buffer =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_sigmoid_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _buffer)));
  }|]

log_sigmoid_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
log_sigmoid_backward_ttt _grad_output _self _buffer =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::log_sigmoid_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _buffer)));
  }|]

rrelu_with_noise_out_tttssbG
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise_out_tttssbG _out _self _noise _lower _upper _training _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , *$(at::Generator* _generator)));
  }|]

rrelu_with_noise_out_tttssb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise_out_tttssb _out _self _noise _lower _upper _training =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_with_noise_out_tttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise_out_tttss _out _self _noise _lower _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)));
  }|]

rrelu_with_noise_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise_out_ttts _out _self _noise _lower =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)));
  }|]

rrelu_with_noise_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rrelu_with_noise_out_ttt _out _self _noise =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)));
  }|]

rrelu_with_noise_ttssbG
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise_ttssbG _self _noise _lower _upper _training _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , *$(at::Generator* _generator)));
  }|]

rrelu_with_noise_ttssb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise_ttssb _self _noise _lower _upper _training =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_with_noise_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise_ttss _self _noise _lower _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)));
  }|]

rrelu_with_noise_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise_tts _self _noise _lower =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)));
  }|]

rrelu_with_noise_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rrelu_with_noise_tt _self _noise =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)));
  }|]

rrelu_with_noise_backward_tttssbb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise_backward_tttssbb _grad_output _self _noise _lower _upper _training _self_is_result =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , $(bool _self_is_result)));
  }|]

rrelu_with_noise__ttssbG
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> Ptr Generator
  -> IO (Ptr Tensor)
rrelu_with_noise__ttssbG _self _noise _lower _upper _training _generator =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)
  , *$(at::Generator* _generator)));
  }|]

rrelu_with_noise__ttssb
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> CBool
  -> IO (Ptr Tensor)
rrelu_with_noise__ttssb _self _noise _lower _upper _training =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)
  , $(bool _training)));
  }|]

rrelu_with_noise__ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise__ttss _self _noise _lower _upper =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)
  , *$(at::Scalar* _upper)));
  }|]

rrelu_with_noise__tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
rrelu_with_noise__tts _self _noise _lower =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)
  , *$(at::Scalar* _lower)));
  }|]

rrelu_with_noise__tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
rrelu_with_noise__tt _self _noise =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::rrelu_with_noise_(
    *$(at::Tensor* _self)
  , *$(at::Tensor* _noise)));
  }|]

softplus_out_ttss
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_out_ttss _out _self _beta _threshold =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)));
  }|]

softplus_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_out_tts _out _self _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)));
  }|]

softplus_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softplus_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

softplus_tss
  :: Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_tss _self _beta _threshold =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)));
  }|]

softplus_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softplus_ts _self _beta =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)));
  }|]

softplus_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
softplus_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus(
    *$(at::Tensor* _self)));
  }|]

softplus_backward_out_tttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softplus_backward_out_tttsst _grad_input _grad_output _self _beta _threshold _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)
  , *$(at::Tensor* _output)));
  }|]

softplus_backward_ttsst
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> Ptr Scalar
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softplus_backward_ttsst _grad_output _self _beta _threshold _output =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softplus_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _beta)
  , *$(at::Scalar* _threshold)
  , *$(at::Tensor* _output)));
  }|]

softshrink_out_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_out_tts _out _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_out_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
softshrink_out_tt _out _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)));
  }|]

softshrink_ts
  :: Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_ts _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink(
    *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_t
  :: Ptr Tensor
  -> IO (Ptr Tensor)
softshrink_t _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink(
    *$(at::Tensor* _self)));
  }|]

softshrink_backward_out_ttts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_backward_out_ttts _grad_input _grad_output _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

softshrink_backward_tts
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Scalar
  -> IO (Ptr Tensor)
softshrink_backward_tts _grad_output _self _lambd =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::softshrink_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Scalar* _lambd)));
  }|]

adaptive_avg_pool2d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool2d_out_ttl _out _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_avg_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool2d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

mkldnn_adaptive_avg_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
mkldnn_adaptive_avg_pool2d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::mkldnn_adaptive_avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

_adaptive_avg_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
_adaptive_avg_pool2d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_adaptive_avg_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

_adaptive_avg_pool2d_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
_adaptive_avg_pool2d_backward_tt _grad_output _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::_adaptive_avg_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_avg_pool3d_out_ttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_out_ttl _out _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_avg_pool3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_tl _self _output_size =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_avg_pool3d_backward_out_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_backward_out_ttt _grad_input _grad_output _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_avg_pool3d_backward_tt
  :: Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_avg_pool3d_backward_tt _grad_output _self =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_avg_pool3d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)));
  }|]

adaptive_max_pool2d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
adaptive_max_pool2d_out_tttl _out _indices _self _output_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool2d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool2d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
adaptive_max_pool2d_tl _self _output_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool2d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool2d_backward_out_tttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool2d_backward_out_tttt _grad_input _grad_output _self _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_max_pool2d_backward_out(
    *$(at::Tensor* _grad_input)
  , *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool2d_backward_ttt
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> IO (Ptr Tensor)
adaptive_max_pool2d_backward_ttt _grad_output _self _indices =
  [C.throwBlock| at::Tensor* { return new at::Tensor(at::adaptive_max_pool2d_backward(
    *$(at::Tensor* _grad_output)
  , *$(at::Tensor* _self)
  , *$(at::Tensor* _indices)));
  }|]

adaptive_max_pool3d_out_tttl
  :: Ptr Tensor
  -> Ptr Tensor
  -> Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
adaptive_max_pool3d_out_tttl _out _indices _self _output_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool3d_out(
    *$(at::Tensor* _out)
  , *$(at::Tensor* _indices)
  , *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

adaptive_max_pool3d_tl
  :: Ptr Tensor
  -> Ptr IntArray
  -> IO (Ptr (StdTuple '(Tensor,Tensor)))
adaptive_max_pool3d_tl _self _output_size =
  [C.throwBlock| std::tuple<at::Tensor,at::Tensor>* { return new std::tuple<at::Tensor,at::Tensor>(at::adaptive_max_pool3d(
    *$(at::Tensor* _self)
  , *$(std::vector<int64_t>* _output_size)));
  }|]

